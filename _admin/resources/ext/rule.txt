正则表达式的基本语法
一个正则表达式，分为三个部分：分隔符，表达式和修饰符。
分隔符可以是除了特殊字符以外的任何字符（比如"/ !"等等），常用的分隔符是"/"。表达式由一些特殊字符（特殊字符详见下面）和非特殊的字符串组成，比如"[a-z0-9_-]+@[a-z0-9_-.]+"可以匹配一个简单的电子邮件字符串。修饰符是用来开启或者关闭某种功能/模式。下面就是一个完整的正则表达式的例子：

/hello.+?hello/is

上面的正则表达式"/"就是分隔符，两个"/"之间的就是表达式，第二个"/"后面的字符串"is"就是修饰符。
在表达式中如果含有分隔符，那么就需要使用转义符号"/"，比如"/hello.+?//hello/is"。转义符号除了用于分隔符外还可以执行特殊字符，全部由字母构成的特殊字符都需要"/"来转义，比如"/d"代表全体数字。
正则表达式的特殊字符
正则表达式中的特殊字符分为元字符、定位字符等等。
元字符是正则表达式中一类有特殊意义的字符，用来描述其前导字符（即元字符前面的字符）在被匹配的对象中出现的方式。元字符本身是一个个单一的字符，但是不同或者相同的元字符组合起来可以构成大的元字符。
元字符：
大括号：大括号用来精确指定匹配元字符出现的次数，例如"/pre{1,5}/"表示匹配的对象可以是"pre"、"pree"、"preeeee"这样在"pr"后面出现1个到5个"e"的字符串。或者"/pre{,5}/"代表pre出现0此到5次之间。
加号："+"字符用来匹配元字符前的字符出现一次或者多次。例如"/ac+/"表示被匹配的对象可以是"act"、"account"、"acccc"等在"a"后面出现一个或者多个"c"的字符串。"+"相当于"{1,}"。
星号："*"字符用来匹配元字符前的字符出现零次或者多次。例如"/ac*/"表示被匹配的对象可以是"app"、"acp"、"accp"等在"a"后面出现零个或者多个"c"的字符串。"*"相当于"{0,}"。
问号："?"字符用来匹配元字符前的字符出现零次或者1次。例如"/ac?/"表示匹配的对象可以是"a"、"acp"、"acwp"这样在"a"后面出现零个或者1个"c"的字符串。"?"在正则表达式中还有一个非常重要的作用，即"贪婪模式"。
还有两个很重要的特殊字符就是"[ ]"。他们可以匹配"[]"之中出现过的字符，比如"/[az]/"可以匹配单个字符"a"或者"z"；如果把上面的表达式改成这样"/[a-z]/"，就可以匹配任何单个小写字母，比如"a"、"b"等等。
如果在"[]"中出现了"^"，代表本表达式不匹配"[]"内出现的字符，比如"/[^a-z]/"不匹配任何小写字母！并且正则表达式给出了几种"[]"的默认值：

[:alpha:]：匹配任何字母

[:alnum:]：匹配任何字母和数字

[:digit:]：匹配任何数字

[:space:]：匹配空格符

[:upper:]：匹配任何大写字母

[:lower:]：匹配任何小写字母

[:punct:]：匹配任何标点符号

[:xdigit:]：匹配任何16进制数字
另外下面这些特殊字符在转义符号"/"转义后代表的含义如下：

s：匹配单个的空格符

S：用于匹配除单个空格符之外的所有字符。

d：用于匹配从0到9的数字，相当于"/[0-9]/"。

w：用于匹配字母，数字或下划线字符，相当于"/[a-zA-Z0-9_]/"。

W：用于匹配所有与w不匹配的字符，相当于"/[^a-zA-Z0-9_]/"。

D：用于匹配任何非10进制的数字字符。

.：用于匹配除换行符之外的所有字符，如果经过修饰符"s"的修饰，"."可以代表任意字符。
利用上面的特殊字符可以很方便的表达一些比较繁琐的模式匹配。例如"//d0000/"利用上面的正则表达式可以匹配万以上，十万一下的整数字符串。
定位字符：
定位字符是正则表达式中又一类非常重要的字符，它的主要作用是用于对字符在匹配对象中的位置进行描述。

^：表示匹配的模式出现在匹配对象的开头（和在"[]"里面不同）

$：表示匹配的模式出现在匹配对象的末尾

空格：表示匹配的模式出现在开始和结尾的两个边界之一

"/^he/"：可以匹配以"he"字符开头的字符串，比如hello、height等等；

"/he$/"：可以匹配以"he"字符结尾的字符串即she等；

"/ he/"：空格开头，和^的作用一样，匹配以he开头的字符串；

"/he /"：空格结束，和$的作用一样，匹配以he结尾的字符串；

"/^he$/"：表示只和字符串"he"匹配。

正则表达式除了可以用户匹配，还可以用括号"()"来记录需要的信息，储存起来，给后面的表达式读取。比如：

/^([a-zA-Z0-9_-]+)@([a-zA-Z0-9_-]+)(.[a-zA-Z0-9_-])$/

就是记录邮件地址的用户名，和邮件地址的服务器地址（形式为username@server.com之类的），在后面如果想要读取记录下来的字符串，只是需要用"转义符＋记录的次序"来读取。比如"/1"就相当于第一个"[a-zA-Z0-9_-]+"，"/2"相当于第二个([a-zA-Z0-9_-]+)，"/3"就是第三个(.[a-zA-Z0-9_-])。但是在PHP中，"/"是一个特殊的字符，需要转义，所以""到了PHP的表达式中就应该写成"//1"。

其他特殊符号：

"|"：或符号"|"和PHP里面的或一样，不过是一个"|"，而不是PHP的两个"||"！意思就是可以是某个字符或者另一个字符串，比如"/abcd|dcba/"可能匹配"abcd"或者"dcba"。
贪婪模式
前面在元字符中提到过"?"还有一个重要的作用，即"贪婪模式"，什么是"贪婪模式"呢？
比如我们要匹配以字母"a"开头字母"b"结尾的字符串，但是需要匹配的字符串在"a"后面含有很多个"b"，比如"a bbbbbbbbbbbbbbbbb"，那正则表达式是会匹配第一个"b"还是最后一个"b"呢？如果你使用了贪婪模式，那么会匹配到最后一个"b"，反之只是匹配到第一个"b"。

使用贪婪模式的表达式如下：

/a.+?b/

/a.+b/U

不使用贪婪模式的如下：

/a.+b/

上面使用了一个修饰符U，详见下面的部分。
修饰符
在正则表达式里面的修饰符可以改变正则的很多特性，使得正则表达式更加适合你的需要（注意：修饰符对于大小写是敏感的，这意味着"e"并不等于"E"）。正则表达式里面的修饰符如下：

i ：如果在修饰符中加上"i"，则正则将会取消大小写敏感性，即"a"和"A" 是一样的。

m：默认的正则开始"^"和结束"$"只是对于正则字符串如果在修饰符中加上"m"，那么开始和结束将会指字符串的每一行：每一行的开头就是"^"，结尾就是"$"。

s：如果在修饰符中加入"s"，那么默认的"."代表除了换行符以外的任何字符将会变成任意字符，也就是包括换行符！

x：如果加上该修饰符，表达式中的空白字符将会被忽略，除非它已经被转义。

e：本修饰符仅仅对于replacement有用，代表在replacement中作为PHP代码。

A：如果使用这个修饰符，那么表达式必须是匹配的字符串中的开头部分。比如说"/a/A"匹配"abcd"。

E：与"m"相反，如果使用这个修饰符，那么"$"将匹配绝对字符串的结尾，而不是换行符前面，默认就打开了这个模式。

U：和问号的作用差不多，用于设置"贪婪模式"。
PCRE相关的正则表达式函数
PHP的Perl兼容正则表达式提供的多个函数，分为模式匹配，替换和匹配数目等等：
1、preg_match ：

函数格式：int preg_match(string pattern, string subject, array [matches]);

这个函数会在string中使用pattern表达式来匹配，如果给定了[regs]，就会将string记录到[regs][0]中，[regs][1]代表使用括号"（）"记录下来的第一个字符串，[regs][2]代表记录下来的第二个字符串，以此类推。preg如果在string中找到了匹配的pattern，就会返回"true"，否则返回"false"。
2、preg_replace ：

函数格式：mixed preg_replace(mixed pattern, mixed replacement, mixed subject);

这个函数会使用将string中符合表达式pattern的字符串全部替换为表达式replacement。如果replacement中需要包含pattern的部分字符，则可以使用"()"来记录，在replacement中只是需要用"/1"来读取。
3、preg_split ：

函数格式：array preg_split(string pattern, string subject, int [limit]);

这个函数和函数split一样，区别仅在与split可以使用简单正则表达式来分割匹配的字符串，而preg_split使用完全的Perl兼容正则表达式。第三个参数limit代表允许返回多少个符合条件的值。
4、preg_grep ：

函数格式：array preg_grep(string patern , array input);

这个函数和preg_match功能基本上，不过preg_grep可以将给定的数组input中的所有元素匹配，返回一个新的数组。 下面举一个例子，比如我们要检查Email地址的格式是否正确：
&lt;?php

function emailIsRight($email) {

if (preg_match("^[_.0-9a-z-]+@([0-9a-z][0-9a-z-]+.)+[a-z]{2,3}$",$email)) {

return 1;

}

return 0;

}

if(emailIsRight('y10k@963.net')) echo '正确&lt;br&gt;';

if(!emailIsRight('y10k@fffff')) echo '不正确&lt;br&gt;';

?&gt;
上面的程序会输出"正确&lt;br&gt;不正确"。
PHP中的Perl兼容正则表达式和Perl/Ereg正则表达式的区别
虽然叫做“Perl兼容正则表达式”，但是和Perl的正则表达式相比，PHP的还是由一些不同，比如修饰符“G”在Perl里面代表全部匹配，但是在PHP中没有加入对这个修饰符的支持。

还有就是和ereg系列函数的区别，ereg也是PHP中提供的正则表达式函数，不过和preg相比，要弱上很多。
1、ereg里面是不需要也不能使用分隔符和修饰符的，所以ereg的功能比preg要弱上不少。

2、关于"."：点在正则里面一般是除了换行符以外的全部字符，但是在ereg里面的"."是任意字符，即包括换行符！如果在preg里面希望"."能够包括换行符，可以在修饰符中加上"s"。

3、ereg默认使用贪婪模式，并且不能修改，这个给很多替换和匹配带来麻烦。

4、速度：这个或许是很多人关心的问题，会不会preg功能强大是以速度来换取的？不用担心，preg的速度要远远比ereg快，笔者做了一个程序测试：
&lt;?php

echo "Preg_replace used time:";

$start = time();

for($i=1;$i&lt;=100000;$i++) {

$str = "ssssssssssssssssssssssssssss";

preg_replace("/s/","",$str);

}

$ended = time()-$start;

echo $ended;

echo "ereg_replace used time:";

$start = time();

for($i=1;$i&lt;=100000;$i++) {

$str = "ssssssssssssssssssssssssssss";

ereg_replace("s","",$str);

}

$ended = time()-$start;

echo $ended;

echo "str_replace used time:";

$start = time();

for($i=1;$i&lt;=100000;$i++) {

$str = "sssssssssssssssssssssssssssss";

str_replace("s","",$str);

}

$ended = time()-$start;

echo $ended;

?&gt;
结果：

Preg_replace used time:5

ereg_replace used time:15

str_replace used time:2

str_replace因为不需要匹配所以速度非常快，而preg_replace的速度比ereg_replace要快上不少。
关于PHP3.0对于preg的支持
在PHP 4.0中默认加入了preg支持，但是在3.0中确没有。如果在3.0中希望使用preg函数，必须加载php3_pcre.dll文件，只要在php.ini的extension部分设置加入"extension = php3_pcre.dll"然后从新启动PHP就可以了！
其实正则表达式还常用于UbbCode的实现，很多PHP论坛都使用了这个方法（比如zForum zphp.com或者vB vbullent.com），但是具体的代码比较长。

正则表达式(regular expression)描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串做替换或者从某个串中取出符合某个条件的子串等。
列目录时，　dir *.txt或ls *.txt中的*.txt就不是一个正则表达式,因为这里*与正则式的*的含义是不同的。
　　为便于理解和记忆，先从一些概念入手，所有特殊字符或字符组合有一个总表在后面，最后一些例子供理解相应的概念。
 
正则表达式

　　是由普通字符（例如字符 a 到 z）以及特殊字符（称为元字符）组成的文字模式。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。
　　可以通过在一对分隔符之间放入表达式模式的各种组件来构造一个正则表达式，即/expression/

普通字符

　　由所有那些未显式指定为元字符的打印和非打印字符组成。这包括所有的大写和小写字母字符，所有数字，所有标点符号以及一些符号。 

非打印字符

字符	含义
/cx	匹配由x指明的控制字符。例如， /cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。
/f	匹配一个换页符。等价于 /x0c 和 /cL。
/n	匹配一个换行符。等价于 /x0a 和 /cJ。
/r	匹配一个回车符。等价于 /x0d 和 /cM。
/s	匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ /f/n/r/t/v]。
/S	匹配任何非空白字符。等价于 [^ /f/n/r/t/v]。
/t	匹配一个制表符。等价于 /x09 和 /cI。
/v	匹配一个垂直制表符。等价于 /x0b 和 /cK。

特殊字符

　　所谓特殊字符，就是一些有特殊含义的字符，如上面说的"*.txt"中的*，简单的说就是表示任何字符串的意思。如果要查找文件名中有＊的文件，则需要对＊进行转义，即在其前加一个/。ls /*.txt。正则表达式有以下特殊字符。
特别字符	说明
$	匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '/n' 或 '/r'。要匹配 $ 字符本身，请使用 /$。
( )	标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 /( 和 /)。
*	匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 /*。
+	匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 /+。
.	匹配除换行符 /n之外的任何单字符。要匹配 .，请使用 /。
[	标记一个中括号表达式的开始。要匹配 [，请使用 /[。
?	匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 /?。
/	将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'/n' 匹配换行符。序列 '//' 匹配 "/"，而 '/(' 则匹配 "("。
^	匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 /^。
{	标记限定符表达式的开始。要匹配 {，请使用 /{。
|	指明两项之间的一个选择。要匹配 |，请使用 /|。

　　构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与操作符将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。
 
限定符

　　限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有*或+或?或{n}或{n,}或{n,m}共6种。
*、+和?限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。
　　正则表达式的限定符有：
字符	描述
*	匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。
+	匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。
?	匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于 {0,1}。
{n}	n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。
{n,}	n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。
{n,m}	m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。

定位符

　　用来描述字符串或单词的边界，^和$分别指字符串的开始与结束，/b描述单词的前或后边界，/B表示非单词边界。不能对定位符使用限定符。

选择

　　用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，是相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。
　　其中?:是非捕获元之一，还有两个非捕获元是?=和?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。

后向引用

　　对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左至右所遇到的内容存储。存储子匹配的缓冲区编号从 1 开始，连续编号直至最大 99 个子表达式。每个缓冲区都可以使用 '/n' 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。
　　可以使用非捕获元字符 '?:', '?=', or '?!' 来忽略对相关匹配的保存。

各种操作符的运算优先级

　　相同优先级的从左到右进行运算，不同优先级的运算先高后低。各种操作符的优先级从高到低如下：
操作符	描述
/	转义符
(), (?:), (?=), []	圆括号和方括号
*, +, ?, {n}, {n,}, {n,m}	限定符
^, $, /anymetacharacter	位置和顺序
|	“或”操作

全部符号解释

字符	描述
/	将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，'n' 匹配字符 "n"。'/n' 匹配一个换行符。序列 '//' 匹配 "/" 而 "/(" 则匹配 "("。
^	匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 '/n' 或 '/r' 之后的位置。
$	匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 '/n' 或 '/r' 之前的位置。
*	匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。
+	匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。
?	匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 中的"do" 。? 等价于 {0,1}。
{n}	n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。
{n,}	n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。
{n,m}	m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。
?	当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 "oooo"，'o+?' 将匹配单个 "o"，而 'o+' 将匹配所有 'o'。
.	匹配除 "/n" 之外的任何单个字符。要匹配包括 '/n' 在内的任何字符，请使用象 '[./n]' 的模式。
(pattern)	匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 '/(' 或 '/)'。
(?:pattern)	匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 "或" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。
(?=pattern)	正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，'Windows (?=95|98|NT|2000)' 能匹配 "Windows 2000" 中的 "Windows" ，但不能匹配 "Windows 3.1" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
(?!pattern)	负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如'Windows (?!95|98|NT|2000)' 能匹配 "Windows 3.1" 中的 "Windows"，但不能匹配 "Windows 2000" 中的 "Windows"。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始
x|y	匹配 x 或 y。例如，'z|food' 能匹配 "z" 或 "food"。'(z|f)ood' 则匹配 "zood" 或 "food"。
[xyz]	字符集合。匹配所包含的任意一个字符。例如， '[abc]' 可以匹配 "plain" 中的 'a'。
[^xyz]	负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 "plain" 中的'p'。
[a-z]	字符范围。匹配指定范围内的任意字符。例如，'[a-z]' 可以匹配 'a' 到 'z' 范围内的任意小写字母字符。
[^a-z]	负值字符范围。匹配任何不在指定范围内的任意字符。例如，'[^a-z]' 可以匹配任何不在 'a' 到 'z' 范围内的任意字符。
/b	匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er/b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。
/B	匹配非单词边界。'er/B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。
/cx	匹配由 x 指明的控制字符。例如， /cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。
/d	匹配一个数字字符。等价于 [0-9]。
/D	匹配一个非数字字符。等价于 [^0-9]。
/f	匹配一个换页符。等价于 /x0c 和 /cL。
/n	匹配一个换行符。等价于 /x0a 和 /cJ。
/r	匹配一个回车符。等价于 /x0d 和 /cM。
/s	匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ /f/n/r/t/v]。
/S	匹配任何非空白字符。等价于 [^ /f/n/r/t/v]。
/t	匹配一个制表符。等价于 /x09 和 /cI。
/v	匹配一个垂直制表符。等价于 /x0b 和 /cK。
/w	匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。
/W	匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。
/xn	匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，'/x41' 匹配 "A"。'/x041' 则等价于 '/x04' &amp; "1"。正则表达式中可以使用 ASCII 编码。.
/num	匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，'(.)/1' 匹配两个连续的相同字符。
/n	标识一个八进制转义值或一个向后引用。如果 /n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。
/nm	标识一个八进制转义值或一个向后引用。如果 /nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 /nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 /nm 将匹配八进制转义值 nm。
/nml	如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。
/un	匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， /u00A9 匹配版权符号 (?)。 






正则表达式是烦琐的，但是强大的，学会之后的应用会让你除了提高效率外，会给你带来绝对的成就感。只要认真去阅读这些资料，加上应用的时候进行一定的参考，掌握正则表达式不是问题。

索引

1. 引子
2. 正则表达式的历史
3. 正则表达式定义

3.1 普通字符
3.2 非打印字符
3.3 特殊字符
3.4 限定符
3.5 定位符
3.6 选择
3.7 后向引用

4. 各种操作符的运算优先级
5. 全部符号解释
6. 部分例子
7. 正则表达式匹配规则

7.1 基本模式匹配
7.2 字符簇
7.3 确定重复出现

1. 引子
　　目前，正则表达式已经在很多软件中得到广泛的应用，包括*nix（Linux, Unix等），HP等操作系统，PHP，C#，Java等开发环境，以及很多的应用软件中，都可以看到正则表达式的影子。

　　正则表达式的使用，可以通过简单的办法来实现强大的功能。为了简单有效而又不失强大，造成了正则表达式代码的难度较大，学习起来也不是很容易，所以需要付出一些努力才行，入门之后参照一定的参考，使用起来还是比较简单有效的。

例子： ^.+@.+\\..+$
　　这样的代码曾经多次把我自己给吓退过。可能很多人也是被这样的代码给吓跑的吧。继续阅读本文将让你也可以自由应用这样的代码。

　　注意：这里的第7部分跟前面的内容看起来似乎有些重复，目的是把前面表格里的部分重新描述了一次，目的是让这些内容更容易理解。

2. 正则表达式的历史
　　正则表达式的“祖先”可以一直上溯至对人类神经系统如何工作的早期研究。Warren McCulloch 和 Walter Pitts 这两位神经生理学家研究出一种数学方式来描述这些神经网络。
　　1956 年, 一位叫 Stephen Kleene 的数学家在 McCulloch 和 Pitts 早期工作的基础上，发表了一篇标题为“神经网事件的表示法”的论文，引入了正则表达式的概念。正则表达式就是用来描述他称为“正则集的代数”的表达式，因此采用“正则表达式”这个术语。

　　随后，发现可以将这一工作应用于使用 Ken Thompson 的计算搜索算法的一些早期研究，Ken Thompson 是 Unix 的主要发明人。正则表达式的第一个实用应用程序就是 Unix 中的 qed 编辑器。

　　如他们所说，剩下的就是众所周知的历史了。从那时起直至现在正则表达式都是基于文本的编辑器和搜索工具中的一个重要部分。

　

3. 正则表达式定义
　　正则表达式(regular expression)描述了一种字符串匹配的模式，可以用来检查一个串是否含有某种子串、将匹配的子串做替换或者从某个串中取出符合某个条件的子串等。

列目录时，　dir *.txt或ls *.txt中的*.txt就不是一个正则表达式,因为这里*与正则式的*的含义是不同的。 
　　正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为元字符）组成的文字模式。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。
3.1 普通字符
　　由所有那些未显式指定为元字符的打印和非打印字符组成。这包括所有的大写和小写字母字符，所有数字，所有标点符号以及一些符号。

3.2 非打印字符
字符 含义
\cx 匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。
\f 匹配一个换页符。等价于 \x0c 和 \cL。
\n 匹配一个换行符。等价于 \x0a 和 \cJ。
\r 匹配一个回车符。等价于 \x0d 和 \cM。
\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
\S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\t 匹配一个制表符。等价于 \x09 和 \cI。
\v 匹配一个垂直制表符。等价于 \x0b 和 \cK。

　
3.3 特殊字符
　　所谓特殊字符，就是一些有特殊含义的字符，如上面说的”*.txt”中的*，简单的说就是表示任何字符串的意思。如果要查找文件名中有＊的文件，则需要对＊进行转义，即在其前加一个\。ls \*.txt。正则表达式有以下特殊字符。
　

特别字符 说明
$ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 \$。
( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。
* 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。
+ 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。
. 匹配除换行符 \n之外的任何单字符。要匹配 .，请使用 \。
[ 标记一个中括号表达式的开始。要匹配 [，请使用 \[。
? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。
\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\\’ 匹配 “\”，而 ‘\(’ 则匹配 “(”。
^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。
{ 标记限定符表达式的开始。要匹配 {，请使用 \{。
| 指明两项之间的一个选择。要匹配 |，请使用 \|。

　　构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与操作符将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。
　

3.4 限定符
　　限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有*或+或?或{n}或{n,}或{n,m}共6种。
*、+和?限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。
　　正则表达式的限定符有：
　 字符 描述
* 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。
+ 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。
? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。
{n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。
{n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。
{n,m} m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。

3.5 定位符
　　用来描述字符串或单词的边界，^和$分别指字符串的开始与结束，\b描述单词的前或后边界，\B表示非单词边界。不能对定位符使用限定符。

3.6 选择
　　用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，是相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。
　　其中?:是非捕获元之一，还有两个非捕获元是?=和?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。

3.7 后向引用
　　对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左至右所遇到的内容存储。存储子匹配的缓冲区编号从 1 开始，连续编号直至最大 99 个子表达式。每个缓冲区都可以使用 ‘\n’ 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。
　　可以使用非捕获元字符 ‘?:’, ‘?=’, or ‘?!’ 来忽略对相关匹配的保存。

4. 各种操作符的运算优先级
　　相同优先级的从左到右进行运算，不同优先级的运算先高后低。各种操作符的优先级从高到低如下：
　 操作符 描述
\ 转义符
(), (?:), (?=), [] 圆括号和方括号
*, +, ?, {n}, {n,}, {n,m} 限定符
^, $, \anymetacharacter 位置和顺序
| “或”操作

5. 全部符号解释

字符 描述
\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\\’ 匹配 “\” 而 “\(” 则匹配 “(”。
^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。
$ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。
* 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。
+ 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。
? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。
{n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。
{n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。
{n,m} m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。
? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。
. 匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。
(pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘\(’ 或 ‘\)’。
(?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。
(?=pattern) 正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，’Windows (?=95|98|NT|2000)’ 能匹配 “Windows 2000″ 中的 “Windows” ，但不能匹配 “Windows 3.1″ 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
(?!pattern) 负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95|98|NT|2000)’ 能匹配 “Windows 3.1″ 中的 “Windows”，但不能匹配 “Windows 2000″ 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始
x|y 匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。
[xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。
[^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p'。
[a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。
[^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。
\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。
\B 匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。
\cx 匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。
\d 匹配一个数字字符。等价于 [0-9]。
\D 匹配一个非数字字符。等价于 [^0-9]。
\f 匹配一个换页符。等价于 \x0c 和 \cL。
\n 匹配一个换行符。等价于 \x0a 和 \cJ。
\r 匹配一个回车符。等价于 \x0d 和 \cM。
\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
\S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\t 匹配一个制表符。等价于 \x09 和 \cI。
\v 匹配一个垂直制表符。等价于 \x0b 和 \cK。
\w 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。
\W 匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。
\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41′ 匹配 “A”。’\x041′ 则等价于 ‘\x04′ & “1″。正则表达式中可以使用 ASCII 编码。.
\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1′ 匹配两个连续的相同字符。
\n 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。
\nm 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。
\nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。
\un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。

　

6. 部分例子

正则表达式 说明
/\b([a-z]+) \1\b/gi 一个单词连续出现的位置
/(\w+):\/\/([^/:]+)(:\d*)?([^# ]*)/ 将一个URL解析为协议、域、端口及相对路径
/^(?:Chapter|Section) [1-9][0-9]{0,1}$/ 定位章节的位置
/[-a-z]/ A至z共26个字母再加一个-号。
/ter\b/ 可匹配chapter，而不能terminal
/\Bapt/ 可匹配chapter，而不能aptitude
/Windows(?=95 |98 |NT )/ 可匹配Windows95或Windows98或WindowsNT,当找到一个匹配后，从Windows后面开始进行下一次的检索匹配。

7. 正则表达式匹配规则
7.1 基本模式匹配

　　一切从最基本的开始。模式，是正规表达式最基本的元素，它们是一组描述字符串特征的字符。模式可以很简单，由普通的字符串组成，也可以非常复杂，往往用特殊的字符表示一个范围内的字符、重复出现，或表示上下文。例如：

^once
　　这个模式包含一个特殊的字符^，表示该模式只匹配那些以once开头的字符串。例如该模式与字符串”once upon a time”匹配，与”There once was a man from NewYork”不匹配。正如如^符号表示开头一样，$符号用来匹配那些以给定模式结尾的字符串。

bucket$
　　这个模式与”Who kept all of this cash in a bucket”匹配，与”buckets”不匹配。字符^和$同时使用时，表示精确匹配（字符串与模式一样）。例如：

^bucket$
　　只匹配字符串”bucket”。如果一个模式不包括^和$，那么它与任何包含该模式的字符串匹配。例如：模式

once
与字符串

There once was a man from NewYork
Who kept all of his cash in a bucket.
是匹配的。

　　在该模式中的字母(o-n-c-e)是字面的字符，也就是说，他们表示该字母本身，数字也是一样的。其他一些稍微复杂的字符，如标点符号和白字符（空格、制表符等），要用到转义序列。所有的转义序列都用反斜杠(\)打头。制表符的转义序列是：\t。所以如果我们要检测一个字符串是否以制表符开头，可以用这个模式：

^\t
类似的，用\n表示“新行”，\r表示回车。其他的特殊符号，可以用在前面加上反斜杠，如反斜杠本身用\\表示，句号.用\.表示，以此类推。

7.2 字符簇

在INTERNET的程序中，正规表达式通常用来验证用户的输入。当用户提交一个form以后，要判断输入的电话号码、地址、EMAIL地址、信用卡号码等是否有效，用普通的基于字面的字符是不够的。

所以要用一种更自由的描述我们要的模式的办法，它就是字符簇。要建立一个表示所有元音字符的字符簇，就把所有的元音字符放在一个方括号里：

[AaEeIiOoUu]
这个模式与任何元音字符匹配，但只能表示一个字符。用连字号可以表示一个字符的范围，如：

[a-z] //匹配所有的小写字母 
[A-Z] //匹配所有的大写字母 
[a-zA-Z] //匹配所有的字母 
[0-9] //匹配所有的数字 
[0-9\.\-] //匹配所有的数字，句号和减号 
[ \f\r\t\n] //匹配所有的白字符
同样的，这些也只表示一个字符，这是一个非常重要的。如果要匹配一个由一个小写字母和一位数字组成的字符串，比如”z2″、”t6″或”g7″，但不是”ab2″、”r2d3″ 或”b52″的话，用这个模式：

^[a-z][0-9]$
尽管[a-z]代表26个字母的范围，但在这里它只能与第一个字符是小写字母的字符串匹配。

前面曾经提到^表示字符串的开头，但它还有另外一个含义。当在一组方括号里使用^是，它表示“非”或“排除”的意思，常常用来剔除某个字符。还用前面的例子，我们要求第一个字符不能是数字：

^[^0-9][0-9]$
这个模式与”&5″、”g7″及”-2″是匹配的，但与”12″、”66″是不匹配的。下面是几个排除特定字符的例子：

[^a-z] //除了小写字母以外的所有字符 
[^\\\/\^] //除了(\)(/)(^)之外的所有字符 
[^\"\'] //除了双引号(")和单引号(')之外的所有字符
特殊字符”.” (点，句号)在正规表达式中用来表示除了“新行”之外的所有字符。所以模式”^.5$”与任何两个字符的、以数字5结尾和以其他非“新行”字符开头的字符串匹配。模式”.”可以匹配任何字符串，除了空串和只包括一个“新行”的字符串。

PHP的正规表达式有一些内置的通用字符簇，列表如下：

字符簇 含义 
[[:alpha:]] 任何字母 
[[:digit:]] 任何数字 
[[:alnum:]] 任何字母和数字 
[[:space:]] 任何白字符 
[[:upper:]] 任何大写字母 
[[:lower:]] 任何小写字母 
[[:punct:]] 任何标点符号 
[[:xdigit:]] 任何16进制的数字，相当于[0-9a-fA-F]
7.3 确定重复出现

到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。

字符簇 含义 
^[a-zA-Z_]$ 所有的字母和下划线 
^[[:alpha:]]{3}$ 所有的3个字母的单词 
^a$ 字母a 
^a{4}$ aaaa 
^a{2,4}$ aa,aaa或aaaa 
^a{1,3}$ a,aa或aaa 
^a{2,}$ 包含多于两个a的字符串 
^a{2,} 如：aardvark和aaab，但apple不行 
a{2,} 如：baad和aaa，但Nantucket不行 
\t{2} 两个制表符 
.{2} 所有的两个字符
这些例子描述了花括号的三种不同的用法。一个数字，{x}的意思是“前面的字符或字符簇只出现x次”；一个数字加逗号，{x,}的意思是“前面的内容出现x或更多的次数”；两个用逗号分隔的数字，{x,y}表示“前面的内容至少出现x次，但不超过y次”。我们可以把模式扩展到更多的单词或数字：

^[a-zA-Z0-9_]{1,}$ //所有包含一个以上的字母、数字或下划线的字符串 
^[0-9]{1,}$ //所有的正数 
^\-{0,1}[0-9]{1,}$ //所有的整数 
^\-{0,1}[0-9]{0,}\.{0,1}[0-9]{0,}$ //所有的小数
最后一个例子不太好理解，是吗？这么看吧：与所有以一个可选的负号(\-{0,1})开头(^)、跟着0个或更多的数字([0-9]{0,})、和一个可选的小数点(\.{0,1})再跟上0个或多个数字([0-9]{0,})，并且没有其他任何东西($)。下面你将知道能够使用的更为简单的方法。

特殊字符”?”与{0,1}是相等的，它们都代表着：“0个或1个前面的内容”或“前面的内容是可选的”。所以刚才的例子可以简化为：

^\-?[0-9]{0,}\.?[0-9]{0,}$
特殊字符”*”与{0,}是相等的，它们都代表着“0个或多个前面的内容”。最后，字符”+”与 {1,}是相等的，表示“1个或多个前面的内容”，所以上面的4个例子可以写成：

^[a-zA-Z0-9_]+$ //所有包含一个以上的字母、数字或下划线的字符串 
^[0-9]+$ //所有的正数 
^\-?[0-9]+$ //所有的整数 
^\-?[0-9]*\.?[0-9]*$ //所有的小数
当然这并不能从技术上降低正规表达式的复杂性，但可以使它们更容易阅读。